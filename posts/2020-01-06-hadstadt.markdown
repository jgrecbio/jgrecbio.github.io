---
title: The RSA hadstadt Attack
---

The Hastadt's attack on broadcast message
=========================================

The RSA cryptosystem has been on a lot of scrutiny since its invention.
The ability for many applications on the internet, like payment between people
estranged to one another among them, relies on the asymetry of RSA. So
far, RSA stands on its feet mathematically. Nobody has ever published a
method that fatally break RSA encryption. One can always speculate that
some intelligence agencies can, but it is only a guess without much
evidence to support it, although now
[768-bit length](https://en.wikipedia.org/wiki/RSA_Factoring_Challenge)
keys are no longer
secure, 1024 should at least be used. 1024 bit-long keys are supposed
to factorized in the
[following years](https://crypto.stackexchange.com/questions/1978/how-big-an-rsa-key-is-considered-secure-today).
By the way, if you feel adventurous,
there is a 100 000$ bounty if you can find the factors of a given RSA key.
It is already believed to be 
possible for some states to crack such keys or are about to be, but at very high cost (probably much
higher than 100 000$).
That is the reason why the research on RSA cryptanalysis has been
mainly focused on what is called a relaxed-mode RSA. Meaning that
weaknesses are deliberatly present or some knowledge about the plaintext are
known by an attacker, let's call that attacker Eve. And of course, Eve
is trying to spy on Bob and Alice. It makes sense to do research on
a so-called relaxed-mode because it mimics RSA implementation errors or
an insecure usage of the RSA cryptosystems. Some of these attacks were
pratical.

Here I will present theThe Hadstadt's attackn which
is easier to understand once the
[Chinese Remainder Problem theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem)
(CRT) has been introduced.

The Chinese Remainder Theorem
-----------------------------

#### Theorem

Let $\{a_i\}^k_{i=1}$ be a set of arbitrary integers and
$\{n_i\}_{i=1}^{k}$ be a set of relatively prime integer. Then there
exist an integer $a$ such a that:
$a \equiv a_i \mod n_i : \forall i \in {1, \ldots, k}$. Moreover, $a'$
is also a solution to this system of congruence, if and only if
$a' \equiv a \mod{n}$.

##### proof

This is a constructive proof, meaning it will provide
a solution to generate the said solution, let's define
$n_i^{*}=n_1 \times \cdots \times n_i / n_i$, $t_i$ such that
$t_i \equiv (n_i^{*})^{-1} \mod{n_i}$ and $e_i = n_i^{*} t_i$. Then
$e_i \equiv 1 \mod n_i$ and $e_i \equiv 0 \mod n_j$. So the sum of
$a_i e_i$ is a solution. If $a' \equiv a \mod{n}$ then:

$$\begin{aligned}
&a - a' = 1 + k \prod_{i=1}^{k} n_i \\
\iff &a \equiv a' \mod{n_i}
\end{aligned}$$

If $\forall i \in \{1, \ldots, k\} : a' \equiv a_i \mod{n_i}$ then
$n_i | (a' - a)$. And as all $n_i$ are relatively prime, this imply that
$n | (a' - a)$. $\square$

The Chinese Remainder Theorem, can be rewritten as the following:
$$\begin{aligned}
\tau : &\mathbb{Z}_n \rightarrow \mathbb{Z}_{n_1} \times \cdots \times \mathbb{Z}_{n_k} \\
        &a \longmapsto ([a]_{n_1}, \cdots, [a]_{n_k})
\end{aligned}$$

Then $\tau$ is a bijection. This statement is important because it implies
that there only one integer in $\mathbb{Z}_n$, which satisfy the set of
equations $a \equiv a_i \mod{n_i}$, for all i. The CRT proof also gives us a very simple
algorithm to compute solutions for a system of congruences. The CRT can
also help us to first compute a result $\mod{p}$ and then $\mod{q}$ and
then $\mod{pq}$, given that $\gcd(p,q) = 1$. In the case of RSA, $p$ and
$q$ are prime, so they are also coprimes, if they are different. We will see
in more details, that it is possible to use the RSA to perform RSA decryption
almost 4 times faster. But it can lead to security risk if it is done improperly.

A very simple attack
--------------------

The Hadstadt's attacks is based on the following idea. Let's imagine
that Bob wants to communicate with three of his friends, each of whom
has its own public and private RSA keys. Although, each of Bob's friend
have different public keys, they are using the same public exponent
$e = 3$ for encryption, or another low value. There is some incentive to
use a small integer as a public exponent. It indeed lower the
computational cost of encryption. Bob wants to tell them to meet at
their favorite restaurant at 5 o'clock, by only sending the number 5
encrypted, which is $5^3=125$. For any attacker, it is then easy to
compute the third root of 125 and then recover the plaintext. So in this
example, with a small public exponent, RSA is insecure for any key size
chosen. The exponentiation must "wrap around" the modulus for the
encryption to be secure. 
Bob immediatly sees that but still wants to keep the cost of
encryption as small as possible. But he realizes that he needs the $m^3$
bigger than any modulus $n_i$ used for encryption. Otherwise a simple
and efficient third root computation is enough to recover the plaintext.
But, even if Bob is doing that, RSA is still very much insecure for this
setting due to Hadstadt message broadcast attack.

The attack
----------

Let $c_i$ be the ciphertext for the i-ieth friend, and
$c_i \equiv m^3 \mod{n}$. To explain, the attack one can suppose that
none of the keys use any of the same prime factor. So all $n_i$ are relatively
prime to one another. Which looks a lot like the premises of the CRT. So
there exist a $c$ which is a solution to the equations
$x \equiv c_i \mod{n_i}$. And of course, as all
$c_i \equiv m^3 \mod{n_i}$, $m^3$ is a solution, so: $c \equiv m^3 \mod{n_1 n_2 n3}$
And ofcourse, as all $c_i \equiv m^3 \mod{n_i}$, $m^3$ is a solution, so
$c \equiv m^3 \mod{n_1 n_2 n_3}$. Or we know that $m \leq n_i$,
so $m^d \leq n_1 n_2 n_3$. So $m^3$ is the unique solution to
this equation below the product of all $n_i$. So one can retrieve the
message by computing the third root of $c$.

```haskell
import Math.NumberTheory.Powers


crt :: [Integer] -> [Integer] -> Integer
crt nis ais = let n = product nis
coprimeNis = map (n `quot`) nis
                  inverseCoPrimeNis = zipWith inverseCoprimes coprimeNis nis
                  res = sum $ zipWith3 (\x y z -> x * y * z) ais coprimeNis inverseCoPrimeNis
               in expSafe res 1 n

hadstadtAttack :: (Ciphertext, Ciphertext, Ciphertext) -> (Moduli, Moduli, Moduli) -> Plaintext
hadstadtAttack (c1, c2, c3) (n1, n2, n3) = integerCubeRoot c
				where c = crt [n1, n2, n3] [c1, c2, c3]
```

The same reasonning can be applied if the same message is sent to 17 persons, and $e = 17$.


Conclusion
----------

So as we've seen, using a small value for public exponent does expose
the RSA cryptosystem to a security flaw. This is the reason why, the
guidelines for building secure RSA cryptosystem implementations advise
to use $e=65537$. Why this integer in particular? 65537 is actually a
prime number from the family of fermat's prime. Fermat's primes are of
the form $2^{2^n} + 1$. This actually helps to optimize the modular
exponentiation algorithm upon which is build the RSA scheme. But, the
modular exponentiation and its algorithm deserve a post on their own.
The code for mounting this attack is fairly simple, this explains why
this attack is very often present in [CTFs](https://cryptopals.com/sets/5/challenges/40)
