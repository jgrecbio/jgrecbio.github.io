<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Harpocrate's adventuresAn Introduction for the RSA cryptosystem</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
		<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
		<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Harpocrate's adventures</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>An Introduction for the RSA cryptosystem</h1>

            <div class="info">
    Posted on January  6, 2020
    
</div>

<h1 id="introduction">Introduction</h1>
<p>This article will assume that the reader has some knowledge of modular arithmetic and is comfortable with <a href="https://en.wikipedia.org/wiki/Modulo_operation">modulo operation</a>, <a href="https://en.wikipedia.org/wiki/Greatest_common_divisor">GCD</a>, the notion of <a href="https://en.wikipedia.org/wiki/Modular_inverse">coprime integers</a>, integer and of <a href="https://en.wikipedia.org/wiki/Prime_number">prime numbers</a>. Here I want to insist on the fact that intergers have inverses modulo <span class="math inline"><em>n</em></span> if and only if they are coprime to <span class="math inline"><em>n</em></span>.</p>
<p>The <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> cryptosystem — named after its co-creators R. Rivers, A. Shamir and L. Adelman — is the most famous asymetric cryptosystem. By asymetric, one means that the keys required for both encryption and decryption are not the same. Although its inception is fairly recent, the mathematics required for RSA has been known for almost 200 years and are not very complicated. It is mostly modular arithmetics, clock algebra as it is sometimes called.</p>
<p>The security of the RSA cryptosystem relies on the difficulty to compute the inverse of modular exponentiation <span class="math inline"><em>a</em><sup><em>x</em></sup> ≡ <em>b</em>mod <em>n</em></span>. In RSA, all operations are performed in <span class="math inline">ℤ<sub><em>n</em></sub> = {0, …, <em>n</em> − 1}</span>. This is the so-called [inverse logarithm problem]. The idea behind RSA is fairly simple as well, it relies upon finding two integers <span class="math inline"><em>e</em></span> and <span class="math inline"><em>d</em></span>, respectively coined public and private exponent, such that for all <span class="math inline"><em>a</em></span> in <span class="math inline">ℤ<sub><em>n</em></sub></span>, <span class="math inline"><em>a</em><sup><em>e</em><em>d</em></sup> ≡ 1mod <em>n</em></span>. Then <span class="math inline"><em>e</em></span>, the public exponent, along with the moduli <span class="math inline"><em>n</em></span>, serve as the public key, and the private exponent <span class="math inline"><em>d</em></span> is the private key. The ability to produce such integers <span class="math inline"><em>e</em></span> and <span class="math inline"><em>d</em></span> is based on the knowledge of the unique integer factorization of <span class="math inline"><em>n</em></span>, which must be the product of two large primes in case of RSA cryptosystem.</p>
<h1 id="the-euler-theorem-or-how-to-generate-e-and-d">The euler theorem or how to generate <span class="math inline"><em>e</em></span> and <span class="math inline"><em>d</em></span></h1>
<p>Let’s define the <a href="https://en.wikipedia.org/wiki/Euler's_totient_function">euler totient function</a> <span class="math inline"><em>ϕ</em>(<em>n</em>)</span>, it simply computes the number of positive integer inferior to <span class="math inline"><em>n</em></span> that are coprime to <span class="math inline"><em>n</em></span>. This set of all coprime to <span class="math inline"><em>n</em></span> is denoted <span class="math inline">ℤ<sub><em>n</em></sub><sup>*</sup></span>. In the case that <span class="math inline"><em>n</em></span> is prime number, the computation of <span class="math inline"><em>ϕ</em>(<em>n</em>)</span> is easy, all the integer below <span class="math inline"><em>n</em></span> are coprime to <span class="math inline"><em>n</em></span>, otherwise <span class="math inline"><em>n</em></span> could not be prime. So, in that case <span class="math inline"><em>ϕ</em>(<em>n</em>) = <em>p</em> − 1</span>.</p>
<p>And there is another neat fact about this function: <br /><span class="math display">$$\begin{aligned}
    \forall a \in \mathbb{Z}_{n}^{*} \\
    a^{\phi(n)} \equiv 1 \mod{n}\end{aligned}$$</span><br /></p>
<h4 id="proof">proof</h4>
<p>Let <span class="math inline">ℤ<sub><em>n</em></sub><sup>*</sup></span> the set of integers coprime to <span class="math inline">ℤ</span> and <span class="math inline"><em>α</em></span> an element of that set. Let <span class="math inline"><em>τ</em><sub><em>α</em></sub></span> be the map: <br /><span class="math display">$$\begin{aligned}
            \mathbb{Z}_{n}^{*} \rightarrow \mathbb{Z}_{n}^{*} \\
            \beta \longmapsto \alpha \beta
    \end{aligned}$$</span><br /> <span class="math inline"><em>τ</em><sub><em>α</em></sub></span> is a bijective map: <br /><span class="math display">$$\begin{aligned}
        &amp;\tau_{\alpha}(\beta) = \tau_{\alpha}(\gamma) \\
        \iff &amp;\alpha \beta = \alpha \gamma \\
        \iff &amp;\beta = \gamma \\
        \implies &amp;\tau_{\alpha} injective \\
    \end{aligned}$$</span><br /> <br /><span class="math display">$$\begin{aligned}
        &amp;\tau_{\alpha}(\alpha^{-1} \beta) = \alpha^{-1} \alpha \beta = \beta \\
        \implies &amp;\tau_{\alpha} surjective
    \end{aligned}$$</span><br /> As <span class="math inline"><em>τ</em><sub><em>α</em></sub></span> bijective: <br /><span class="math display">$$\begin{aligned}
        &amp;\displaystyle\prod_{\beta \in \mathbb{Z}_{n}^{*}} \tau_{\alpha}(\beta) = \displaystyle\prod_{\beta \in \mathbb{Z}_{n}^{*}} \beta \\
        \iff &amp;\alpha^{\phi(n)} \displaystyle\prod_{\beta \in \mathbb{Z}_{n}^{*}} \beta =
        \displaystyle\prod_{\beta \in \mathbb{Z}_{n}^{*}} \beta \\
        \iff &amp;\alpha^{\phi(n)} \equiv 1 \mod{n}
    \end{aligned}$$</span><br /></p>
<p>Moreover there is a neat formula to compute <span class="math inline"><em>ϕ</em><em>n</em></span> if <span class="math inline"><em>p</em></span>, <span class="math inline"><em>q</em></span> the unique factors of <span class="math inline"><em>n</em></span> are known, <span class="math inline"><em>ϕ</em><em>n</em> = (<em>p</em> − 1)(<em>q</em> − 1)</span>. Once <span class="math inline"><em>ϕ</em>(<em>n</em>)</span> is known, once can select an invertible integer <span class="math inline"><em>e</em></span> in <span class="math inline">ℤ<sub><em>ϕ</em>(<em>n</em>)</sub><sup>*</sup></span> and let <span class="math inline"><em>d</em></span> be its unique inverse in <span class="math inline">ℤ<sub><em>ϕ</em>(<em>n</em>)</sub><sup>*</sup></span>. By definition <span class="math inline"><em>e</em><em>d</em> ≡ 1mod <em>ϕ</em>(<em>n</em>) ⇔ <em>e</em><em>d</em> = <em>k</em><em>ϕ</em>(<em>n</em>) + 1</span>. So let <span class="math inline"><em>a</em> ∈ ℤ<sub><em>n</em></sub><sup>*</sup></span>, then <span class="math inline"><em>a</em><sup><em>k</em><em>ϕ</em>(<em>n</em>) + 1</sup> ≡ <em>a</em>mod <em>n</em></span>, which shows that the decryption process works if <span class="math inline"><em>a</em></span> is invertible. What if it is not the case:</p>
<p>Let’s compute the same modular exponentiation <span class="math inline">mod <em>p</em></span> for an integer <span class="math inline"><em>b</em></span> which is not invertile modulo <span class="math inline"><em>n</em></span>. <br /><span class="math display">$$\begin{aligned}
    b^{ed} &amp;\equiv b^{k(p - 1)(q - 1)} \times b \mod{p}, k \in \mathbb{Z} \\
           &amp;\equiv (b^{p - 1})^{k(q - 1)}\end{aligned}$$</span><br /></p>
<p>By using the euler theorem, as <span class="math inline"><em>ϕ</em>(<em>p</em>) = <em>p</em> − 1</span>, one can prove that <span class="math inline"><em>a</em><sup><em>p</em> − 1</sup> ≡ 1mod <em>p</em></span> as <span class="math inline"><em>p</em></span> is a prime number. By the way this fact is called fermat’s little theorem. So <span class="math inline"><em>b</em><sup><em>e</em><em>d</em></sup> ≡ <em>b</em>mod <em>p</em></span>. By applying the same reasonning, <span class="math inline"><em>b</em><sup><em>e</em><em>d</em></sup> ≡ <em>b</em>mod <em>q</em></span>. So one can see that <span class="math inline"><em>b</em><sup><em>e</em><em>d</em></sup> ≡ <em>b</em>mod <em>n</em></span>, which shows that decryption process works for all integer below <span class="math inline"><em>n</em></span>.</p>
<h1 id="write-your-own-very-insecure-rsa">Write your own (very insecure RSA)</h1>
<p>You may have heard about that rule: <a href="http://loup-vaillant.fr/articles/rolling-your-own-crypto">never roll your own crypto</a>. And I’m about to do just that and then never use it! But I want to show how easy to write a simple RSA scheme. In haskell, the goto library to find secure and efficient cryptography primitives is <a href="https://hackage.haskell.org/package/cryptonite">cryptonite</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="dt">Crypto.Number.Prime</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">import</span> <span class="dt">Crypte.Number.ModArithmetic</span></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="ot">keyGeneration ::</span> <span class="dt">MonadRandom</span> m <span class="ot">=&gt;</span> m (<span class="dt">Integer</span>, <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb1-5" title="5">keyGeneration <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-6" title="6">	p <span class="ot">&lt;-</span> generatePrime <span class="dv">512</span></a>
<a class="sourceLine" id="cb1-7" title="7">	q <span class="ot">&lt;-</span> generatePrime <span class="dv">512</span></a>
<a class="sourceLine" id="cb1-8" title="8">	<span class="fu">return</span> (p, q)</a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="ot">generateExponents ::</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>) <span class="ot">-&gt;</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>, <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb1-11" title="11">generateExponents (p, q) <span class="fu">=</span> (n, e, d)</a>
<a class="sourceLine" id="cb1-12" title="12">	<span class="kw">where</span> n <span class="fu">=</span> p <span class="fu">*</span> q</a>
<a class="sourceLine" id="cb1-13" title="13">		  phi <span class="fu">=</span> (p <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">*</span> (q <span class="fu">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-14" title="14">		  e <span class="fu">=</span> <span class="dv">65337</span></a>
<a class="sourceLine" id="cb1-15" title="15">		  d <span class="fu">=</span> inverseCoprimes e phi</a></code></pre></div>
<p>As explained, <span class="math inline"><em>e</em></span> is the public exponent and <span class="math inline"><em>d</em></span> is the private exponent. It is recommended to chose <span class="math inline"><em>e</em></span> as a prime so that it is coprime to <span class="math inline"><em>ϕ</em>(<em>p</em><em>q</em>)</span>. <span class="math inline"><em>e</em></span> is here a fermat prime, which speeds up the modular expoentiation algorithm which will be the subject for a later post. Once the keys are generated, let’s show the encryption process:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">type</span> <span class="dt">PublicExponent</span> <span class="fu">=</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">type</span> <span class="dt">Plaintext</span> <span class="fu">=</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">type</span> <span class="dt">Moduli</span> <span class="fu">=</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">type</span> <span class="dt">Ciphertext</span> <span class="fu">=</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="ot">encrypt ::</span> <span class="dt">PublicExponent</span> <span class="ot">-&gt;</span> <span class="dt">Moduli</span> <span class="ot">-&gt;</span> <span class="dt">Plaintext</span> <span class="ot">-&gt;</span> <span class="dt">Ciphertext</span></a>
<a class="sourceLine" id="cb2-7" title="7">encrypt e n plaintext <span class="fu">=</span> expSafe plaintext e n</a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="ot">decrypt ::</span> <span class="dt">PrivateExponent</span> <span class="ot">-&gt;</span> <span class="dt">Moduli</span> <span class="ot">-&gt;</span> <span class="dt">Ciphertext</span> <span class="ot">-&gt;</span> <span class="dt">Plaintext</span></a>
<a class="sourceLine" id="cb2-10" title="10">decrypt d n ciphertex <span class="fu">=</span> expSafe ciphertext d n</a></code></pre></div>
<p>And that’s it.</p>
<h1 id="conclusion">Conclusion</h1>
<p>I just described what is called the schoolbook RSA. In order to make that cryptographic scheme secure, many more elements and verification are needed. And I want to insist on that, using the RSA this way is grossly insecure. By the way some specialists are <a href="https://blog.trailofbits.com/2019/07/08/fuck-rsa/">advocating</a> to move out from RSA (very strongly) as implementing a safe RSA system is a very hard feat. In the following posts, I will show and exploit some the weaknesses that the RSA cryptosystem can display. The first of these will be the Hadstadt attack.</p>

        </div>
		<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <div id="footer">
            Site proudly generated by
           <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
