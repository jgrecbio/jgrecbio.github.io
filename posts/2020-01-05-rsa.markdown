---
title: An Introduction for the RSA cryptosystem
---

*This article will assume that the reader has some knowledge of modular arithmetic and is comfortable with [modulo operations](https://en.wikipedia.org/wiki/Modulo_operation),
[GCD](https://en.wikipedia.org/wiki/Greatest_common_divisor), the notion of
[coprime integers](https://en.wikipedia.org/wiki/Modular_inverse)
and of [prime numbers](https://en.wikipedia.org/wiki/Prime_number). Here I want to
insist on the fact that integers have inverses modulo $n$ if and only
if they are coprime to $n$.*

Introduction
============

The [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)) cryptosystem
--- named after its co-creators R. Rivers, A.
Shamir and L. Adelman --- is the most famous asymetric cryptosystem. By
asymetric, one means that the keys required for both encryption and
decryption are not the same. Although its inception is fairly recent,
the mathematics required for RSA has been known for almost 200 years and
are not very complicated. It is mostly modular arithmetics, clock
algebra as it is sometimes called.

The security of the RSA cryptosystem relies on the difficulty to compute
the inverse of modular exponentiation $a^x \equiv b \mod{n}$. In RSA,
all operations are performed in $\mathbb{Z}_n = \{0, \ldots, n - 1\}$.
This is the so-called [inverse logarithm problem](https://en.wikipedia.org/wiki/Discrete_logarithm).
The idea behind RSA is
fairly simple as well, it relies upon finding two integers $e$ and $d$,
respectively coined public and private exponent, such that for all $a$
in $\mathbb{Z}_n$, $a^{ed} \equiv 1 \mod{n}$. Then $e$, the public
exponent, along with the moduli $n$, serve as the public key, and the
private exponent $d$ is the private key. The ability to produce such
integer $e$ and $d$ is based on the knowledge of the unique integer
factorization of $n$, which must be the product of two large primes in
case of RSA cryptosystem.

The euler theorem or how to generate $e$ and $d$
================================================

Let's define the [euler totient function](https://en.wikipedia.org/wiki/Euler's_totient_function) $\phi(n)$, it simply computes
the number of positive integer inferior to $n$ that are coprime to $n$.
This set of all coprime to $n$ is denoted $\mathbb{Z}_n^{*}$. In the
case that $p$ is a prime number, the computation of $\phi(p)$ is easy, all
the integer below $p$ are coprime to $p$, otherwise $p$ could not be
prime. So, in that case $\phi(p) = p - 1$. Take 11 for example, as it
is a prime number, it has no common factor with any integer below eleven
(beside 1 which is the trivial factor), which makes 10 - 1 coprimes.
Compared to 12, where each number divisible by both 2 and 3 has common factor with 12.

And there is another neat fact about this function:
$$\begin{aligned}
    \forall a \in \mathbb{Z}_{n}^{*}, a^{\phi(n)} \equiv 1 \mod{n}
\end{aligned}$$

#### proof

Let $\mathbb{Z}_{n}^{*}$ the set of integers coprime to $n$ and let
$\alpha$ be an element of that set. Let $\tau_{\alpha}$ be the map (or function):
$$\begin{aligned}
	\mathbb{Z}_{n}^{*} \rightarrow \mathbb{Z}_{n}^{*} \\
	\beta \longmapsto \alpha \beta
\end{aligned}$$

It is possible to prove that $\tau_{\alpha}$
is a [bijective map](https://en.wikipedia.org/wiki/Bijection). 
$$\begin{aligned}
        &\tau_{\alpha}(\beta) = \tau_{\alpha}(\gamma) \\
        \iff &\alpha \beta = \alpha \gamma \\
        \iff &\beta = \gamma \\
        \implies &\tau_{\alpha} injective \\
    \end{aligned}$$
$$\begin{aligned}
        &\tau_{\alpha}(\alpha^{-1} \beta) = \alpha^{-1} \alpha \beta = \beta \\
        \implies &\tau_{\alpha} surjective
\end{aligned}$$
As $\tau_{\alpha}$ bijective, it means that this function has a
one-to-one relation with each element of the input domain to the output domain.
One easy conclusion from that is that there is the same number of element in
the input and output domains, which is the result that helps prove the following statements:
$$\begin{aligned}
        &\displaystyle\prod_{\beta \in \mathbb{Z}_{n}^{*}} \tau_{\alpha}(\beta) = \displaystyle\prod_{\beta \in \mathbb{Z}_{n}^{*}} \beta \\
        \iff &\alpha^{\phi(n)} \displaystyle\prod_{\beta \in \mathbb{Z}_{n}^{*}} \beta =
        \displaystyle\prod_{\beta \in \mathbb{Z}_{n}^{*}} \beta \\
        \iff &\alpha^{\phi(n)} \equiv 1 \mod{n}
\end{aligned}$$

Moreover there is a neat formula to compute $\phi(n)$ if $p$, $q$ the
unique factors of $n$ are known, $\phi(n) = (p - 1)(q - 1)$. Once
$\phi(n)$ is known, once can select an invertible integer $e$ in
$\mathbb{Z}_{\phi(n)}^{*}$ and let $d$ be its unique inverse in
$\mathbb{Z}_{\phi(n)}^{*}$.
By definition
$ed \equiv 1 \mod{\phi(n)} \iff ed = k\phi(n) + 1$, for some $k$. So let
$a \in \mathbb{Z}_{n}^{*}$, then $a^{k\phi(n) + 1} \equiv (a^{\phi(n)})^k \times a \equiv a \mod{n}$,
which shows that the decryption process works if $a$ is invertible. What
if it is not the case:

Let's compute the same modular exponentiation $\mod{p}$ for an integer
$b$ which is not invertible modulo $n$. $$\begin{aligned}
    b^{ed} &\equiv b^{k(p - 1)(q - 1)} \times b \mod{p}, k \in \mathbb{Z} \\
           &\equiv (b^{p - 1})^{k(q - 1)}\end{aligned}$$

By using the euler theorem, as $\phi(p) = p - 1$, one can prove that
$a^{p - 1} \equiv 1 \mod{p}$ as $p$ is a prime number. By the way this
fact is called
[fermat's little theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem).
So $b^{ed} \equiv b \mod{p}$. By
applying the same reasoning, $b^{ed} \equiv b \mod{q}$. So one can see
that $b^{ed} \equiv b \mod{n}$, which shows that decryption process
works for all integer below $n$. In the case, it does not appear evident,
which was not the first time for me either, playing with the meaning of this
system of equations with a pen and paper should help a lot.
Also the [next article](./2020-01-06-hadstadt.html)
will help with a special abstraction, the chinese remainder
theorem.

Write your own (very insecure RSA)
==================================

You may have heard about that rule: [never roll your own crypto](http://loup-vaillant.fr/articles/rolling-your-own-crypto). And I'm
about to do just that and then never use it! But I want to show how easy
to write a simple RSA scheme. In haskell, the goto library to find secure
and efficient cryptography primitives is [cryptonite](https://hackage.haskell.org/package/cryptonite).

```haskell
import Crypto.Number.Prime
import Crypte.Number.ModArithmetic

keyGeneration :: MonadRandom m => m (Integer, Integer)
keyGeneration = do
	p <- generatePrime 512
	q <- generatePrime 512
	return (p, q)

generateExponents :: (Integer, Integer)
				      -> (Integer, Integer, Integer)
generateExponents (p, q) = (n, e, d)
	where n = p * q
		  phi = (p - 1) * (q - 1)
		  e = 65337
		  d = inverseCoprimes e phi
```

As explained, $e$ is the public exponent and $d$ is the private exponent. It is
recommended to chose $e$ as a prime so that it is coprime to $\phi(pq)$.
$e$ is here a fermat prime, which speeds up the modular exponentiation algorithm
which will be the subject for a later post.
Once the keys are generated, let's show the encryption process:

```haskell
type PublicExponent = Integer
type Plaintext = Integer
type Moduli = Integer
type Ciphertext = Integer

encrypt :: PublicExponent
		   -> Moduli
           -> Plaintext
           -> Ciphertext
encrypt e n plaintext = expSafe plaintext e n

decrypt :: PrivateExponent
           -> Moduli
           -> Ciphertext
           -> Plaintext
decrypt d n ciphertex = expSafe ciphertext d n
```

And that's it.

Conclusion
==========

I just described what is called the schoolbook RSA. In order to make
that cryptographic scheme secure, many more elements and verification
are needed. And I want to insist on that, using the RSA this way is
grossly insecure. By the way, some specialists are
[advocating](https://blog.trailofbits.com/2019/07/08/fuck-rsa/) to move
out from RSA (very strongly) as implementing a safe RSA system is a very hard feat.
 In the following posts, I will show and exploit some the
weaknesses that the RSA cryptosystem can display. The first of these
will be the [Hadstadt's broadcast message attack](./2020-01-06-hadstadt.html).
